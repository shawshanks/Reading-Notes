# TCP传输中的问题
## 1.操作系统是怎样关闭套接字连接的P45
操作系统的网络栈部分需要非常谨慎地处理连接的关闭.
#### 1.监听套接字
`socke.listen()`对套接字调用`listen()`会彻底将该套接字改变为监听套接字,再也不能用于发送或接收数据,也不会与任何特定的客户端连接.

该套接字只能通过`accept()`方法来接受连接请求. (`accept()`唯一的目的就是用于支持TCP套接字的监听功能)

#####关闭: 可以立即关闭并且被操作系统忽略
#### 2.实际与客户端通信的套接字 accpet()方法返回的套接字
因为最后的一个FIN确认数据报可能被网络丢弃,那么另一方就无法得知对方是否的确想要关闭连接.可能会重新发送FIN数据报,希望最后能收到响应.

一旦应用程序认为某个TCP连接最终关闭了,操作系统会在保持该连接4分钟,以便响应对方的FIN报文.

##### 问题
这样当服务器再次绑定上个TCP使用的连接端口时,其实是在试图使用某种意义上还在使用的端口,因此通过`bind()`方法绑定改地址时会返回错误.

##### 解决
设定套接字选项SO_REUSEADDR,应用程序能够使用一些网络客户端之前正在关闭的端口.

### 半开连接
套接字是双向连接的,意味着双方都可以向对方发送信息.

当一方认为自己不再需要发送数据时,可以调用`shutdown()`. 这样对方也知道自己不会再发送数据.

#### close()与shutdown() 的区别
close()仅仅结束了调用他的进程与套接字的关系,此时如果其他进程仍然使用该套接字的话,该套接字仍然是可用的. 而shutdown()方法, 本来使用这个套接字的所有进程都不能再使用这个套接字了.

## 2 数据发送问题
### 2.1 如何确保数据全部发送和全部接收 p43
### 2.2 当需要处理数据的特定部分时,如何知道信息的状态(每段数据的开始,结束)
### 2.3 如何防止在处理大量问题死锁问题 p47
客户端发送数据,服务器接收然后返回,客户端不接受,服务器端缓存区溢出,无法接收数据,客户端缓存区溢出,无法再发送数据,造成死锁---> 



